# xcache缓存

## 介绍

1. 本缓存模块是在freecache的理解的基础之上，以及内存的管理思想之上思考的一个cache框架。
本缓存分为两部分，第一部分是元数据的管理，元数据里面包括了大小，位置，过期时间，删除等信息，这个数据是无指针的数据，存储到map中，无指针的map不会被gc扫描
第二部分，是数据的管理，这部分的数据存储了key，value的数据。整个数据被分成了65535个桶，每个桶存储8bytes的数据。这样的话，所有的key value大小会进行桶计算，
然后存储到对应的桶里面。也就是说，同一个桶里面的数据，大小相差不超过8bytes。删除数据的时候，桶里面的数据不会被清理，只会做一个删除的标志，并把删除的标志放到
一个queue里面。下一次，如果来了新的存储的数据，先检查queue里面有没有多余的空间位置，有的话，直接获取数据，然后清空，并存储新的数据。如果删除的queue里面没有空间
那么，就申请一个桶对应的新的空间，然后存储进去，并获取一个位置。
2. 每个桶里面的添加和删除会被计数，主要是为了检查活跃的桶，在后期数据清空的时候，先会清理不活跃的桶里面的数据，然后清理活跃的桶
3. 元数据的存储，通过对key进行hash，然后获取uint32长度，然后分成一个65535*65535的一个matrix，里面存放元数据。
关于hash重复的处理，重复的元素放到了go-adaptive-radix-tree，这是一个前缀树的实现。检查的时候，会先判断go-adaptive-radix-tree是否有数据，
如果有的话，那么，就从go-adaptive-radix-tree取数据。go-adaptive-radix-tree里面只存放重复的数据，数据必然不会太多，所以，查询效率会高效很多。

2. 本缓存模块对存储的key长度, 缓存大小, 缓存策略, 内存清理, 过期时间, 数据加载, 过期驱逐进行定义和描述
3. 提供默认的大小长度限制, 并允许使用者自己设置最大的限制


## Key长度限制
1. 最小Key长度5
2. 最大Key长度65535

## 缓存策略, 应该是插件
1. 防止雪崩，让同一时刻缓存的时间做一下抖动处理，默认时间+随机时间(0,2s)
2. 防止穿透，对于缓存不存在数据库也不存在的数据，缓存存储一个空值null，并设置极小的过期时间(2s)
3. 防止击穿，如果并发访问不存在缓存数据, 会给数据库造成很大压力，那么，当发现数据不存在的时候，锁住对数据源的访问，其他的访问暂时等待，数据获取成功后，解开锁，其他访问正常
4. 考虑过期数据 可以使用, 防止从数据库获取数据，等待时间过长。


## 缓存内存大小限制
1. 最小缓存 10*1024*1024
2. 最大缓存 500*1024*1024


## 缓存清理
1. 使用者添加缓存时，对缓存大小和当前缓存进行判断
    1. 没有超过，正常流程
    2. 超过最大缓存的扩展(20%)，清理过期缓存，直接报错
    3. 超过最大缓存，清理过期缓存，直接存储
2. 设置定时清理, 定时清理过期的缓存。该函数属于全局函数，请全局设置 `InitJanitor(interval time.Duration)`


## 过期时间限制
1. 最小过期时间2s
2. 最大过期时间1m, 使用者可以重新设置, 但是不能超过默认最大过期时间
3. **默认过期时间**需要使用者设置(WithDefaultExpiration)


## 过期驱逐设置 `OnEvicted(f func(k, v []byte))`
1. 使用者可以设置过期驱逐回调，当删除过期缓存时，回调该函数


## 数据加载设置 `OnDataLoad(f func([]byte) ([]byte, error))`
1. 当缓存中没有数据时，缓存通过数据加载函数获取数据，并存储到缓存中
2. 如果数据加载报错，该错误会给使用者的获取缓存的调用中
